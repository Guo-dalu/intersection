(function(){"use strict";const S="runSingleIntersection",g="runMultipleIntersection",l="singleIntersectionResult",u="multipleIntersectionResult",T="error",d=(e,t)=>{const n=new Set;return t.forEach(s=>{n.add(s)}),e.filter(s=>n.has(s)).length},r=e=>Array.from({length:e}).map(()=>Math.round(Math.random()*(e-1))),i=({min:e=0,max:t=1})=>{if(t<=e)throw new Error("max should be greater than min");return e+Math.round(Math.random()*(t-e))},m=({size1:e,size2:t,iterateCollection:n})=>{const s=performance.now(),a=n==="A"?e:t,c=n==="B"?e:t,o=d(r(a),r(c));return{time:performance.now()-s,commonSize:o}},h=({min:e=1e3,max:t=5e5,times:n,iterateCollection:s})=>Array.from({length:n}).map(()=>{const a=r(i({min:e,max:t})),c=r(i({min:e,max:t})),o=a.length,I=c.length,{time:M,commonSize:E}=m({size1:o,size2:I,iterateCollection:s});return{size1:o,size2:I,time:M,commonSize:E}});onmessage=e=>{const{message:t,data:n}=e.data;try{switch(t){case S:postMessage({message:l,data:m(n)});break;case g:postMessage({message:u,data:h(n)});break;default:break}}catch{postMessage({message:T})}}})();
